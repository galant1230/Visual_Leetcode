
<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>235. BST 最近共同祖先動畫</title>
  <style>
    body { font-family: sans-serif; background: #f8f9fa; padding: 2rem; }
    .tree-container { text-align: center; margin-top: 2rem; }
    .level { display: flex; justify-content: center; margin: 6px 0; }
    .node {
      width: 40px; height: 40px;
      border: 2px solid #3498db;
      border-radius: 50%;
      background: white;
      color: #3498db;
      display: flex; align-items: center; justify-content: center;
      font-weight: bold;
      margin: 4px;
      cursor: pointer;
    }
    .highlight { background: #ffeaa7; color: #000; }
    .pnode { background: #74b9ff !important; color: white; }
    .qnode { background: #fab1a0 !important; color: white; }
    .lcanode { background: #2ecc71 !important; color: white; }
    .info { text-align: center; margin-top: 1rem; font-size: 16px; }
    input, button { font-size: 1rem; margin: 0.5rem; padding: 0.3rem 0.6rem; }
    button { background: #2980b9; color: white; border: none; border-radius: 5px; cursor: pointer; }
  </style>
</head>
<body>

<h1>🌳 235. 最近共同祖先（LCA） - BST 動畫</h1>

<div style="text-align:center;">
  <label>Level Order Tree：</label>
  <input id="inputTree" value="[6,2,8,0,4,7,9,null,null,3,5]" style="width:360px;" />
  <br/>
  <button onclick="start()">初始化樹</button>
  <button onclick="findLCA()">尋找 LCA</button>
</div>


<div class="info" style="margin-top:20px; text-align:left; background:#ecf0f1; padding:1rem; border-left:6px solid #3498db;">
  <h3>📝 使用說明：</h3>
  <ul>
    <li>先點第一個節點，會標成 <span style="color:#0984e3;"><b>藍色</b>（p）</span></li>
    <li>再點第二個節點，會標成 <span style="color:#d63031;"><b>紅色</b>（q）</span></li>
    <li>按下 <b>「尋找 LCA」</b> ➜ 開始根據 BST 規則比對並找出最近共同祖先</li>
    <li>結果會以 <span style="color:#27ae60;"><b>綠色</b>節點</span> 顯示</li>
  </ul>
</div>
<div class="tree-container" id="tree"></div>

<div class="info" id="info">點兩個節點作為 p, q</div>

<script>
let id = 0, selected = [], root = null;

class TreeNode {
  constructor(val) {
    this.val = val;
    this.left = null;
    this.right = null;
    this.id = id++;
  }
}

function buildTree(arr) {
  if (!arr.length || arr[0] === null) return null;
  let root = new TreeNode(arr[0]);
  let queue = [root];
  let i = 1;
  while (queue.length && i < arr.length) {
    let node = queue.shift();
    if (arr[i] !== null) {
      node.left = new TreeNode(arr[i]);
      queue.push(node.left);
    }
    i++;
    if (i < arr.length && arr[i] !== null) {
      node.right = new TreeNode(arr[i]);
      queue.push(node.right);
    }
    i++;
  }
  return root;
}

function renderTree(root) {
  const treeEl = document.getElementById("tree");
  treeEl.innerHTML = "";
  const levels = [];
  function dfs(node, depth, pos) {
    if (!node) return;
    if (!levels[depth]) levels[depth] = [];
    levels[depth][pos] = node;
    dfs(node.left, depth + 1, pos * 2);
    dfs(node.right, depth + 1, pos * 2 + 1);
  }
  dfs(root, 0, 0);
  levels.forEach(row => {
    const r = document.createElement("div");
    r.className = "level";
    row.forEach(n => {
      const d = document.createElement("div");
      d.className = "node";
      d.id = "n" + n.id;
      d.innerText = n.val;
      d.onclick = () => selectNode(n);
      r.appendChild(d);
    });
    treeEl.appendChild(r);
  });
}

function selectNode(node) {
  const el = document.getElementById("n" + node.id);
  if (selected.length === 2) {
    selected = [];
    document.querySelectorAll(".node").forEach(n => n.classList.remove("pnode", "qnode", "lcanode"));
  }
  selected.push(node);
  if (selected.length === 1) el.classList.add("pnode");
  if (selected.length === 2) el.classList.add("qnode");
  document.getElementById("info").innerText = selected.length === 2 ? "點『尋找 LCA』吧！" : "已選一個節點";
}

function findLCA() {
  if (selected.length < 2) return;
  const p = selected[0], q = selected[1];
  function dfs(node) {
    if (!node) return null;
    const nid = "n" + node.id;
    document.getElementById(nid).classList.add("highlight");
    if (p.val < node.val && q.val < node.val) return dfs(node.left);
    if (p.val > node.val && q.val > node.val) return dfs(node.right);
    return node;
  }
  
setTimeout(() => {
  const result = dfs(root);
  if (result) {
    document.getElementById("n" + result.id).classList.add("lcanode");
    document.getElementById("info").innerHTML = `✅ LCA 是 <b>${result.val}</b>`;
  }
}, 100);

  if (lca) {
    document.getElementById("n" + lca.id).classList.add("lcanode");
    document.getElementById("info").innerHTML = `✅ LCA 是 <b>${lca.val}</b>`;
  }
}

function start() {
  const arr = JSON.parse(document.getElementById("inputTree").value);
  id = 0; selected = [];
  document.getElementById("info").innerText = "點兩個節點作為 p, q";
  root = buildTree(arr);
  renderTree(root);
}
</script>


<h2>🔧 Python 解法</h2>
<pre><code class="language-python">class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if not root:
            return None

        # 若 p 和 q 都比 root 小，往左子樹找
        if p.val < root.val and q.val < root.val:
            return self.lowestCommonAncestor(root.left, p, q)

        # 若 p 和 q 都比 root 大，往右子樹找
        if p.val > root.val and q.val > root.val:
            return self.lowestCommonAncestor(root.right, p, q)

        # 其他情況，root 就是最近共同祖先
        return root
</code></pre>

<h2>📘 解法說明</h2>
<div class="box">
<ul>
  <li>利用 BST 的性質：左 < root < 右</li>
  <li>如果 p 和 q 都小於 root，往左子樹找</li>
  <li>如果 p 和 q 都大於 root，往右子樹找</li>
  <li>如果一個在左、一個在右，或其中一個等於 root，那 root 就是最近共同祖先</li>
</ul>
</div>

<h2>💡 Tips</h2>
<div class="tips">
<ul>
  <li>這題限定在 BST ➜ 可利用順序性快速決策路徑</li>
  <li>普通 Binary Tree 則需 postorder 回傳 flag 或路徑比對</li>
  <li>可用遞迴或迴圈（迴圈可省遞迴空間）</li>
</ul>
</div>

<h2>⏱ 時間與空間複雜度</h2>
<div class="box">
<ul>
  <li><strong>時間複雜度：</strong>O(h)</li>
  <li><strong>空間複雜度：</strong>O(h)</li>
</ul>
<p>h 為樹高，平均為 O(log n)，最差為 O(n)（退化為鏈狀）</p>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
</body>

</html>
