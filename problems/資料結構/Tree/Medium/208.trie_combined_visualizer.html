
<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>Trie è¦–è¦ºåŒ–æ•´åˆç‰ˆ</title>
  <style>
    body { font-family: sans-serif; background: #f9f9fb; padding: 2rem; }
    h1, h2 { text-align: center; }
    .code-box {
      background: #f0f0f0; padding: 1rem; border-radius: 8px;
      max-width: 700px; margin: 1rem auto; font-family: monospace;
    }
    .line { padding: 2px 0; white-space: pre; }
    .highlight { background-color: #ffe082; font-weight: bold; }
    .tree { margin-top: 2rem; text-align: center; }
    .node {
      display: inline-block; margin: 0.25rem; padding: 0.5rem 1rem;
      border: 2px solid #34495e; border-radius: 8px;
    }
    .btns, .input-box { text-align: center; margin: 1rem; }
    button {
      padding: 0.5rem 1rem; margin: 0.5rem; font-size: 1rem;
      background: #34495e; color: white; border: none; border-radius: 6px;
      cursor: pointer;
    }
    input {
      padding: 6px; font-size: 1rem; width: 200px;
    }
  ul { list-style-type: none; padding-left: 1em; }
</style>
</head>
<body>

<h1>ğŸŒ² Trie è¦–è¦ºåŒ–æ•´åˆç‰ˆ</h1>
<div class="code-box" style="max-width: 900px; margin-top: 2rem;">
  <h2>âœ… 208. å¯¦ä½œ Trieï¼ˆå‰ç¶´æ¨¹ï¼‰</h2>
  <p><strong>é›£åº¦ï¼š</strong>ä¸­ç­‰ï¼ˆMediumï¼‰</p>

  <h3>ğŸ§¾ é¡Œç›®èªªæ˜</h3>
  <p>Trieï¼ˆç™¼éŸ³ç‚º "try"ï¼Œåˆç¨±ç‚ºã€Œå‰ç¶´æ¨¹ã€ï¼‰æ˜¯ä¸€ç¨®<strong>æ¨¹ç‹€è³‡æ–™çµæ§‹</strong>ï¼Œå°ˆé–€ç”¨ä¾†<strong>é«˜æ•ˆå„²å­˜èˆ‡æŸ¥è©¢å­—ä¸²é›†åˆä¸­çš„éµå€¼ï¼ˆkeyï¼‰</strong>ã€‚</p>
  <p>å¸¸è¦‹æ‡‰ç”¨åŒ…æ‹¬ï¼š</p>
  <ul>
    <li>ğŸ”¤ è‡ªå‹•è£œå…¨ï¼ˆAutocompleteï¼‰</li>
    <li>ğŸ“ æ‹¼å­—æª¢æŸ¥ï¼ˆSpell Checkerï¼‰</li>
    <li>ğŸ“š å­—å…¸æŸ¥è©¢</li>
    <li>ğŸ” å‰ç¶´æœå°‹ï¼ˆPrefix Matchingï¼‰</li>
  </ul>

  <h3>ğŸ“¦ æ–¹æ³•èªªæ˜</h3>
  <ul>
    <li><code>Trie()</code>ï¼šåˆå§‹åŒ–ä¸€å€‹ Trie ç‰©ä»¶</li>
    <li><code>void insert(String word)</code>ï¼šå°‡å­—ä¸² <code>word</code> æ’å…¥ Trie ä¸­</li>
    <li><code>boolean search(String word)</code>ï¼šæŸ¥è©¢å®Œæ•´å­—ä¸²æ˜¯å¦å­˜åœ¨</li>
    <li><code>boolean startsWith(String prefix)</code>ï¼šæŸ¥è©¢æ˜¯å¦æœ‰å­—ä¸²ä»¥ <code>prefix</code> ç‚ºé–‹é ­</li>
  </ul>

  <h3>â± æ™‚é–“èˆ‡ç©ºé–“è¤‡é›œåº¦åˆ†æ</h3>
  <table border="1" cellpadding="5" cellspacing="0">
    <tr><th>æ“ä½œ</th><th>æ™‚é–“è¤‡é›œåº¦</th><th>ç©ºé–“è¤‡é›œåº¦</th><th>èªªæ˜</th></tr>
    <tr><td>insert</td><td>O(n)</td><td>O(n)</td><td>æ¯å€‹æ–°å­—å…ƒå»ºç«‹ç¯€é»</td></tr>
    <tr><td>search</td><td>O(n)</td><td>O(1)</td><td>åªæŸ¥æ‰¾</td></tr>
    <tr><td>startsWith</td><td>O(n)</td><td>O(1)</td><td>åªæŸ¥æ‰¾</td></tr>
    <tr><td>Trie ç¸½ç©ºé–“</td><td>â€“</td><td>O(m Ã— n)</td><td>m å€‹å­—ä¸²ã€å¹³å‡é•·åº¦ n</td></tr>
  </table>

  <h3>ğŸ· ä¸»é¡Œæ¨™ç±¤</h3>
  <ul>
    <li>ğŸ“ è¨­è¨ˆï¼ˆDesignï¼‰</li>
    <li>ğŸ“š è³‡æ–™çµæ§‹ï¼ˆData Structureï¼‰</li>
    <li>ğŸŒ² å­—å…¸æ¨¹ / å‰ç¶´æ¨¹ï¼ˆTrieï¼‰</li>
  </ul>
</div>


<div class="input-box">
  <input id="inputWord" placeholder="è«‹è¼¸å…¥å­—ä¸²ï¼Œå¦‚ app" />
</div>

<div id="messageBox" style="text-align:center; font-weight:bold; color:#2c3e50; margin-top:1em;"></div>
<div class="btns">
  <button onclick="start('insert')">insert()</button>
  <button onclick="start('search')">search()</button>
  <button onclick="start('startsWith')">startsWith()</button>
  <button onclick="nextStep()">ä¸‹ä¸€æ­¥ â–¶ï¸</button>
  <button onclick="reset()">é‡è¨­ ğŸ”</button>
</div>

<h2 id="modeTitle">è«‹é¸æ“‡æ“ä½œ</h2>
<div class="code-box" id="codeBox"></div>
<div class="tree" id="tree">
  <div class="node">root</div>
</div>

<script>
let trie = { children: {}, end: false };
let path = [];
let word = "";
let index = 0;
let step = 0;
let mode = "";

const codes = {
  insert: [
    "def insert(self, word):",
    "    cur = self.ds",
    "    for ch in word:",
    "        if ch in cur.children:",
    "            cur = cur.children[ch]",
    "        else:",
    "            cur.children[ch] = TrieNode()",
    "            cur = cur.children[ch]",
    "    cur.end = True"
  ],
  search: [
    "def search(self, word):",
    "    cur = self.ds",
    "    for ch in word:",
    "        if ch not in cur.children:",
    "            return False",
    "        cur = cur.children[ch]",
    "    return cur.end"
  ],
  startsWith: [
    "def startsWith(self, prefix):",
    "    cur = self.ds",
    "    for ch in prefix:",
    "        if ch not in cur.children:",
    "            return False",
    "        cur = cur.children[ch]",
    "    return True"
  ]
};

function renderCode() {
  let box = document.getElementById("codeBox");
  box.innerHTML = "";
  if (!mode) return;
  codes[mode].forEach((line, i) => {
    box.innerHTML += `<div class='line' id='line${i}'>${line}</div>`;
  });
}

function highlight(i) {
  let lines = codes[mode].length;
  for (let j = 0; j < lines; j++) {
    document.getElementById("line" + j)?.classList.remove("highlight");
  }
  if (i >= 0) document.getElementById("line" + i)?.classList.add("highlight");
}

function start(selectedMode) {
  mode = selectedMode;
  path = [];
  index = 0;
  step = 0;
  word = document.getElementById("inputWord").value.trim();
  document.getElementById("modeTitle").innerText = "æ¨¡å¼ï¼š" + mode + "()";
  renderCode();
  highlight(-1);
  renderTree();
}

function nextStep() {
  if (!mode || !word) return;
  let cur = trie;
  for (let i = 0; i < path.length; i++) cur = cur.children[path[i]];
  let ch = word[index];

  if (mode === "insert") {
    if (step === 0) { highlight(1); step++; }
    else if (step === 1) { highlight(2); step++; }
    else if (step === 2) {
      if (cur.children[ch]) { highlight(3); step = 4; }
      else { highlight(5); step = 3; }
    }
    else if (step === 3) {
      cur.children[ch] = { children: {}, end: false };
      highlight(6); step = 4;
    }
    else if (step === 4) {
      path.push(ch); index++; highlight(7);
      step = index >= word.length ? 5 : 2;
    }
    else if (step === 5) {
      for (let i = 0, n = trie; i < path.length; i++) n = n.children[path[i]];
      n.end = true;
      highlight(8); document.getElementById("messageBox").innerText = "âœ… å–®å­—å·²æˆåŠŸæ’å…¥ï¼"; step++;
    }
  }

  if (mode === "search" || mode === "startsWith") {
    if (step === 0) { highlight(1); step++; }
    else if (step === 1) { highlight(2); step++; }
    else if (step === 2) {
      if (!cur.children[ch]) { highlight(3); step = -1; document.getElementById("messageBox").innerText = "âŒ æŸ¥ç„¡ '" + ch + "'"; }
      else { highlight(5); path.push(ch); index++; step = index >= word.length ? 4 : 2; }
    }
    else if (step === 4) {
      if (mode === "search") {
        highlight(6);
        for (let i = 0, n = trie; i < path.length; i++) n = n.children[path[i]];
        document.getElementById("messageBox").innerText = (n.end ? "âœ… å–®å­—å­˜åœ¨ï¼(å®Œæ•´å–®å­—)" : "âŒ æŸ¥åˆ°çš„æ˜¯å‰ç¶´ï¼Œä¸æ˜¯å®Œæ•´å–®å­—ï¼");
      } else {
        highlight(6); document.getElementById("messageBox").innerText = "âœ… å‰ç¶´å­˜åœ¨ï¼";
      }
    }
  }

  renderTree();
}

function reset() {
  index = 0; step = 0; path = []; mode = ""; word = "";
  document.getElementById("inputWord").value = "";
  document.getElementById("modeTitle").innerText = "è«‹é¸æ“‡æ“ä½œ";
  renderTree(); document.getElementById("codeBox").innerHTML = "";
}

function renderTree() {
  const container = document.getElementById("tree");
  container.innerHTML = renderNode(trie);
}

function renderNode(node) {
  function walk(n) {
    let html = "<ul>";
    for (const key in n.children) {
      const child = n.children[key];
      html += "<li><div class='node'>" + key + (child.end ? " (âœ“)" : "") + "</div>";
      html += walk(child);
      html += "</li>";
    }
    html += "</ul>";
    return html;
  }
  return "<div class='node'>root</div>" + walk(node);
}

reset();
</script>

</body>
</html>
