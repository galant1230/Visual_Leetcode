<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>Max Depth 可視化模擬器</title>
  <style>
    body {
      font-family: 'Segoe UI', sans-serif;
      background: #f9f9f9;
      padding: 2rem;
      margin: 0;
      color: #333;
    }
    h2, h3 {
      color: #007acc;
    }
    .container {
      max-width: 900px;
      margin: auto;
      background: #fff;
      padding: 2rem;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.08);
    }
    .layer {
      display: flex;
      justify-content: center;
      margin: 1rem 0;
    }
    .node-wrap {
      position: relative;
      margin: 0 10px;
    }
    .node {
      min-width: 40px;
      height: 40px;
      line-height: 40px;
      border-radius: 50%;
      background: #fff;
      border: 2px solid #3498db;
      color: #3498db;
      font-weight: bold;
      text-align: center;
    }
    .node.highlight { background: #f39c12; color: white; }
    .return-label {
      position: absolute;
      top: -24px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 14px;
      color: red;
      font-weight: bold;
    }
    .code-line {
      font-family: monospace;
      padding: 2px 0;
    }
    .active-code { background: #444; color: white; }
    #codeBox {
      background: #272822;
      color: #f8f8f2;
      padding: 1rem;
      border-radius: 6px;
      margin: 2rem 0;
      font-family: monospace;
    }
    #stackBox {
      background: #fff;
      border: 1px solid #aaa;
      padding: 1rem;
      max-width: 200px;
      margin: auto;
      border-radius: 6px;
    }
    .stack-frame {
      padding: 5px;
      border-bottom: 1px solid #ccc;
      text-align: center;
    }
    button {
      padding: 8px 16px;
      font-size: 14px;
      margin: 0.3rem;
      cursor: pointer;
      border: none;
      border-radius: 6px;
      background: #007acc;
      color: white;
    }
    input {
      padding: 6px;
      margin: 0.2rem;
      font-size: 14px;
      width: 300px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>🌲 104. 二元樹最大深度（Max Depth of Binary Tree）</h2>

    <hr>
    <h3>📘 題目描述</h3>
    <p>給定一棵二元樹，請回傳其最大深度。</p>
    <p>最大深度是從根節點到最遠葉節點的最長路徑上的節點數。</p>

    <hr>
    <h3>🧪 範例</h3>
    <pre><code>輸入: [1,2,3,null,null,4]
輸出: 3</code></pre>

    <hr>
    <h3>⏳ 時間與空間複雜度</h3>
    <p><strong>時間複雜度：</strong> <code>O(n)</code>，每個節點都會被拜訪一次。</p>
    <p><strong>空間複雜度：</strong> <code>O(h)</code>，其中 <code>h</code> 為樹的高度（遞迴堆疊）。</p>

    <hr>
    <h3>▶️ 模擬器</h3>
    <div style="text-align:center;">
      <p>輸入樹（BFS）：如 <code>[1,2,3,null,null,4]</code></p>
      <input id="treeInput" value="[1,2,3,null,null,4]" />
      <button onclick="buildTree()">🔃 建立樹</button>
    </div>

    <div id="tree" class="tree-container"></div>

    <div id="codeBox">
      <div class="code-line" id="c1">1: def maxDepth(root):</div>
      <div class="code-line" id="c2">2: &nbsp;&nbsp;if not root: return 0</div>
      <div class="code-line" id="c3">3: &nbsp;&nbsp;left = maxDepth(root.left)</div>
      <div class="code-line" id="c4">4: &nbsp;&nbsp;right = maxDepth(root.right)</div>
      <div class="code-line" id="c5">5: &nbsp;&nbsp;return max(left, right) + 1</div>
    </div>

    <div style="text-align:center;">
      <button onclick="reset()">🔄 重設</button>
      <button onclick="nextStep()">🧭 下一步</button>
    </div>
  </div>

  <script>
    let tree = [], steps = [], current = 0;

    function buildTree() {
      const input = document.getElementById("treeInput").value;
      const arr = JSON.parse(input);
      const nodes = arr.map(val => val === null ? null : { val, left: null, right: null, ret: null });
      let i = 0, j = 1;
      while (j < nodes.length) {
        if (nodes[i]) {
          nodes[i].left = nodes[j++] || null;
          if (j < nodes.length) nodes[i].right = nodes[j++] || null;
        }
        i++;
      }
      tree = nodes[0];
      renderTree(nodes);
      generateSteps(tree);
      current = 0;
      document.getElementById("stackBox").innerHTML = "";
    }

    function renderTree(nodes) {
      const levels = [], queue = [[nodes[0], 0]];
      while (queue.length) {
        const [node, level] = queue.shift();
        if (!levels[level]) levels[level] = [];
        levels[level].push(node);
        if (node) {
          queue.push([node.left, level + 1]);
          queue.push([node.right, level + 1]);
        }
      }
      const container = document.getElementById("tree");
      container.innerHTML = "";
      levels.forEach(layer => {
        const div = document.createElement("div");
        div.className = "layer";
        layer.forEach(n => {
          const wrap = document.createElement("div");
          wrap.className = "node-wrap";
          const el = document.createElement("div");
          el.className = "node";
          el.innerText = n ? n.val : "";
          if (n) el.id = "node-" + n.val + Math.random().toString(36).substring(2, 5);
          n && (n._domId = el.id);
          const ret = document.createElement("div");
          ret.className = "return-label";
          ret.id = el.id + "-ret";
          wrap.appendChild(ret);
          wrap.appendChild(el);
          div.appendChild(wrap);
        });
        container.appendChild(div);
      });
    }

    function highlightLine(n) {
      document.querySelectorAll(".code-line").forEach(e => e.classList.remove("active-code"));
      const el = document.getElementById("c" + n);
      el && el.classList.add("active-code");
    }

    function highlightNode(id) {
      document.querySelectorAll(".node").forEach(e => e.classList.remove("highlight"));
      const el = document.getElementById(id);
      el && el.classList.add("highlight");
    }

    function pushStack(text) {
      const box = document.getElementById("stackBox");
      const frame = document.createElement("div");
      frame.className = "stack-frame";
      frame.innerText = text;
      box.prepend(frame);
    }

    function popStack() {
      const box = document.getElementById("stackBox");
      if (box.firstChild) box.removeChild(box.firstChild);
    }

    function setReturnVal(node, val) {
      if (!node || !node._domId) return;
      const el = document.getElementById(node._domId + "-ret");
      if (el) el.innerText = val;
    }

    function generateSteps(root) {
      steps = [];
      function dfs(node) {
        if (!node) {
          steps.push({ line: 2, node: null, action: 'return', value: 0 });
          return 0;
        }
        steps.push({ line: 1, node, action: 'enter' });
        pushStack("maxDepth(" + node.val + ")");
        highlightNode(node._domId);
        steps.push({ line: 3, node, action: 'left' });
        const left = dfs(node.left);
        steps.push({ line: 4, node, action: 'right' });
        const right = dfs(node.right);
        const ret = Math.max(left, right) + 1;
        steps.push({ line: 5, node, action: 'return', value: ret });
        node.ret = ret;
        popStack();
        return ret;
      }
      dfs(root);
    }

    function nextStep() {
      if (current >= steps.length) return;
      const step = steps[current++];
      highlightLine(step.line);
      highlightNode(step.node ? step.node._domId : null);
      if (step.action === "return") {
        setReturnVal(step.node, step.value);
      }
    }

    function reset() {
      buildTree();
    }
  </script>
</body>
</html>

