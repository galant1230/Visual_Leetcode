
<!DOCTYPE html>

<html lang="zh-Hant">
<head>
<meta charset="utf-8"/>
<title>104. äºŒå…ƒæ¨¹æœ€å¤§æ·±åº¦ - å›å‚³å€¼è¦–è¦ºåŒ–ç‰ˆ</title>
<style>
    body { font-family: sans-serif; background: #f5f7fa; padding: 2rem; }
    h1 { text-align: center; color: #007acc; }
    .tree-container { text-align: center; margin-top: 2rem; }
    .layer { display: flex; justify-content: center; margin: 1rem 0; }
    .node-wrap { position: relative; margin: 0 10px; }
    .node {
      min-width: 40px;
      height: 40px;
      line-height: 40px;
      border-radius: 50%;
      background: #fff;
      border: 2px solid #3498db;
      color: #3498db;
      font-weight: bold;
    }
    .node.highlight { background: #f39c12; color: white; }
    .return-label {
      position: absolute;
      top: -24px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 14px;
      color: red;
      font-weight: bold;
    }
    .code-line {
      font-family: monospace;
      padding: 2px 0;
    }
    .active-code { background: #444; color: white; }
    #codeBox {
      background: #272822;
      color: #f8f8f2;
      padding: 1rem;
      border-radius: 6px;
      max-width: 700px;
      margin: 2rem auto;
    }
    #stackBox {
      background: #fff;
      border: 1px solid #aaa;
      padding: 1rem;
      max-width: 200px;
      margin: auto;
      border-radius: 6px;
    }
    .stack-frame {
      padding: 5px;
      border-bottom: 1px solid #ccc;
      text-align: center;
    }
    button {
      background: #007acc;
      color: white;
      padding: 10px 16px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      margin: 1rem;
    }
    input {
      padding: 5px;
      font-size: 16px;
      width: 300px;
    }
  
    h2, h3 {
      color: #007acc;
    }
    .container {
      max-width: 800px;
      margin: auto;
      background: #fff;
      padding: 2rem;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.08);
    }
    ul {
      padding-left: 1.2rem;
    }
    </style>
</head>
<body><div class="container">
<h2>ğŸŒ² 104. äºŒå…ƒæ¨¹çš„æœ€å¤§æ·±åº¦ï¼ˆMaximum Depth of Binary Treeï¼‰</h2>
<hr/>
<h3>ğŸ“˜ é¡Œç›®æè¿°</h3>
<p>çµ¦å®šä¸€å€‹äºŒå…ƒæ¨¹çš„æ ¹ç¯€é» <code>root</code>ï¼Œè«‹å›å‚³å®ƒçš„æœ€å¤§æ·±åº¦ã€‚</p>
<p>äºŒå…ƒæ¨¹çš„ã€Œæœ€å¤§æ·±åº¦ã€æ˜¯å¾æ ¹ç¯€é»åˆ°æœ€é è‘‰ç¯€é»çš„æœ€é•·è·¯å¾‘ä¸Šçš„ç¯€é»æ•¸ã€‚</p>
<hr/>
<h3>ğŸ§ª ç¯„ä¾‹</h3>
<pre><code>è¼¸å…¥ï¼šroot = [3,9,20,null,null,15,7]
è¼¸å‡ºï¼š3
è§£é‡‹ï¼šå…¶æœ€å¤§æ·±åº¦ç‚º 3ï¼Œå°æ‡‰å¦‚ä¸‹çµæ§‹ï¼š

      3
     / \
    9  20
      /  \
     15   7
</code></pre>
<hr/>
<h3>â³ æ™‚é–“èˆ‡ç©ºé–“è¤‡é›œåº¦</h3>
<p><strong>æ™‚é–“è¤‡é›œåº¦ï¼ˆTime Complexityï¼‰</strong></p>
<ul>
<li>æ¯å€‹ç¯€é»åƒ…è¨ªå•ä¸€æ¬¡ â†’ <code>O(n)</code></li>
</ul>
<p><strong>ç©ºé–“è¤‡é›œåº¦ï¼ˆSpace Complexityï¼‰</strong></p>
<ul>
<li>æœ€å£æƒ…æ³ä¸‹éè¿´æ·±åº¦ç­‰æ–¼æ¨¹çš„é«˜åº¦ â†’ <code>O(h)</code>ï¼Œh ç‚ºæ¨¹é«˜</li>
</ul>

<h1>äºŒå…ƒæ¨¹æœ€å¤§æ·±åº¦è¦–è¦ºåŒ–</h1>
<hr/>
<h3>ğŸŒ€ éè¿´å‘¼å«ç´€éŒ„</h3>
<ul id="logList" style="background:#eef3f7;padding:1rem;border-radius:8px;"></ul>
<h3>ğŸ“¤ æ¯ä¸€å±¤ return çš„å€¼</h3>
<ul id="returnList" style="background:#eef3f7;padding:1rem;border-radius:8px;"></ul>
<div style="text-align:center;">
<p>è¼¸å…¥æ¨¹ï¼ˆBFSï¼‰ï¼šå¦‚ <code>[1,2,3,null,null,4]</code></p>
<input id="treeInput" value="[1,2,3,null,null,4]"/>
<button onclick="buildTree()">å»ºç«‹æ¨¹</button>
</div>
<div class="tree-container" id="tree"></div>
<div id="codeBox">
<div class="code-line" id="c1">1: def maxDepth(root):</div>
<div class="code-line" id="c2">2: Â Â if not root: return 0</div>
<div class="code-line" id="c3">3: Â Â left = maxDepth(root.left)</div>
<div class="code-line" id="c4">4: Â Â right = maxDepth(root.right)</div>
<div class="code-line" id="c5">5: Â Â return max(left, right) + 1</div>
</div>
<div style="text-align:center;">
<button onclick="nextStep()">ä¸‹ä¸€æ­¥</button>
<button onclick="reset()">é‡ç½®</button>
</div>
<h3 style="text-align:center;">éè¿´å‘¼å«å †ç–Š</h3>
<div id="stackBox"></div>
<script>
let tree = [], steps = [], current = 0;

function buildTree() {
  const input = document.getElementById("treeInput").value;
  const arr = JSON.parse(input);
  const nodes = [];
  arr.forEach(val => nodes.push(val === null ? null : { val, left: null, right: null, ret: null }));
  let i = 0, j = 1;
  while (j < nodes.length) {
    if (nodes[i]) {
      nodes[i].left = nodes[j++] || null;
      if (j < nodes.length) nodes[i].right = nodes[j++] || null;
    }
    i++;
  }
  tree = nodes[0];
  renderTree(nodes);
  generateSteps(tree);
  current = 0;
  document.getElementById("stackBox").innerHTML = "";
}

function renderTree(nodes) {
  const levels = [], queue = [[nodes[0], 0]];
  while (queue.length) {
    const [node, level] = queue.shift();
    if (!levels[level]) levels[level] = [];
    levels[level].push(node);
    if (node) {
      queue.push([node.left, level + 1]);
      queue.push([node.right, level + 1]);
    }
  }
  const container = document.getElementById("tree");
  container.innerHTML = "";
  levels.forEach(layer => {
    const div = document.createElement("div");
    div.className = "layer";
    layer.forEach(n => {
      const wrap = document.createElement("div");
      wrap.className = "node-wrap";
      const el = document.createElement("div");
      el.className = "node";
      el.innerText = n ? n.val : "";
      if (n) el.id = "node-" + n.val + Math.random().toString(36).substring(2, 5);
      n && (n._domId = el.id);
      const ret = document.createElement("div");
      ret.className = "return-label";
      ret.id = el.id + "-ret";
      wrap.appendChild(ret);
      wrap.appendChild(el);
      div.appendChild(wrap);
    });
    container.appendChild(div);
  });
}

function highlightLine(n) {
  document.querySelectorAll(".code-line").forEach(e => e.classList.remove("active-code"));
  const el = document.getElementById("c" + n);
  el && el.classList.add("active-code");
}

function highlightNode(id) {
  document.querySelectorAll(".node").forEach(e => e.classList.remove("highlight"));
  const el = document.getElementById(id);
  el && el.classList.add("highlight");
}

function pushStack(text) {
  const box = document.getElementById("stackBox");
  const frame = document.createElement("div");
  frame.className = "stack-frame";
  frame.innerText = text;
  box.prepend(frame);
}

function popStack() {
  const box = document.getElementById("stackBox");
  if (box.firstChild) box.removeChild(box.firstChild);
}

function setReturnVal(node, val) {
  if (!node || !node._domId) return;
  const el = document.getElementById(node._domId + "-ret");
  if (el) el.innerText = val;
}

function generateSteps(root) {
  steps = [];
  function dfs(node) {
    if (!node) {
      steps.push({ line: 2, node: null, action: 'return', value: 0 });
      return 0;
    }
    steps.push({ line: 1, node, action: 'enter' });
    pushStack("maxDepth(" + node.val + ")");
    highlightNode(node._domId);
    steps.push({ line: 3, node, action: 'left' });
    const left = dfs(node.left);
    steps.push({ line: 4, node, action: 'right' });
    const right = dfs(node.right);
    const ret = Math.max(left, right) + 1;
    steps.push({ line: 5, node, action: 'return', value: ret });
    node.ret = ret;
    popStack();
    return ret;
  }
  dfs(root);
}

function nextStep() {
  if (current >= steps.length) return;
  const step = steps[current++];
  highlightLine(step.line);
  highlightNode(step.node ? step.node._domId : null);
  
if (step.action === "enter") {
  appendLog("å‘¼å« dfs(" + step.node.val + ")");
}
if (step.action === "return") {
  appendReturn("ç¯€é» " + step.node.val + " å›å‚³ " + step.value);

    setReturnVal(step.node, step.value);
  }
}

function reset() {
  buildTree();
}


function appendLog(text) {
  const li = document.createElement("li");
  li.innerText = text;
  document.getElementById("logList").appendChild(li);
}

function appendReturn(text) {
  const li = document.createElement("li");
  li.innerText = text;
  document.getElementById("returnList").appendChild(li);
}
</script>
</div></body>
</html>
