
<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <title>LeetCode 300 - Longest Increasing Subsequence</title>
  <style>
    body { font-family: sans-serif; background: #f0f4f8; padding: 2rem; line-height: 1.6; }
    h1, h2 { color: #2c3e50; }
    pre.code-block {
      background: #2d2d2d; color: #f8f8f2; padding: 1rem;
      border-radius: 8px; font-family: monospace;
      line-height: 1.5; overflow-x: auto;
    }
    .array, .label-row { display: flex; justify-content: center; margin: 0.5rem 0; flex-wrap: wrap; }
    .cell {
      width: 50px; height: 50px; border: 2px solid #ccc;
      margin: 2px; display: flex; align-items: center; justify-content: center;
      background: white; font-size: 18px;
    }
    .cell.active { background: #ffeaa7; border-color: #fdcb6e; }
    .cell.lis { background: #74b9ff; border-color: #0984e3; color: white; }
    .dp-row, .result, .tip, .complexity { font-family: monospace; text-align: center; margin-top: 0.5rem; }
    button { margin: 0.5rem; padding: 0.5rem 1rem; font-size: 16px; }
    .label { width: 50px; text-align: center; font-size: 14px; }
  </style>
</head>
<body>

<h1>📈 LeetCode 300 - Longest Increasing Subsequence</h1>

<h2>📌 題目描述</h2>
<p>給定一個整數陣列 <code>nums</code>，回傳其中最長<strong>嚴格遞增子序列</strong>的長度。</p>

<h2>🔹 範例</h2>
<pre><code>Input: nums = [10,9,2,5,3,7,101,18]
Output: 4
Explanation: 最長遞增子序列為 [2,3,7,101]</code></pre>

<h2>🧠 解法：動態規劃 O(n^2)</h2>
<pre class="code-block">
class Solution:
    def lengthOfLIS(self, nums):
        dp = [1] * len(nums)
        for i in range(1, len(nums)):
            for j in range(i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i], dp[j] + 1)
        return max(dp)
</pre>

<h2>⚡ 雙指針視覺化</h2>
<div class="label-row" id="indexRow"></div>
<div class="array" id="array"></div>
<div class="dp-row" id="dp">dp: []</div>
<div class="result" id="result">LIS 長度：0</div>
<div style="text-align:center">
  <button onclick="step()">下一步</button>
  <button onclick="reset()">重置</button>
  <button onclick="toggle()">切換到 O(n log n)</button>
</div>

<div id="lognSection" style="display:none;">
  <h2>🧠 解法：O(n log n)</h2>
  <p>使用 binary search（<code>bisect</code>）與 patience sorting 來追蹤 tails：</p>
  <pre class="code-block">
class Solution:
    def lengthOfLIS(self, nums):
        import bisect
        tails = []
        for num in nums:
            idx = bisect.bisect_left(tails, num)
            if idx == len(tails):
                tails.append(num)
            else:
                tails[idx] = num
        return len(tails)
  </pre>
</div>

<script>
const nums = [10, 9, 2, 5, 3, 7, 101, 18];
let dp = [], i = 1, j = 0;
let cells = [], labels = [];

function build() {
  const arrayDiv = document.getElementById("array");
  const labelDiv = document.getElementById("indexRow");
  arrayDiv.innerHTML = "";
  labelDiv.innerHTML = "";
  cells = [];
  labels = [];

  nums.forEach((num, idx) => {
    const div = document.createElement("div");
    div.className = "cell";
    div.textContent = num;
    arrayDiv.appendChild(div);
    cells.push(div);

    const label = document.createElement("div");
    label.className = "label";
    labelDiv.appendChild(label);
    labels.push(label);
  });

  dp = Array(nums.length).fill(1);
  updateDP();
  updateIJLabels();
  document.getElementById("result").textContent = "LIS 長度：0";
}

function updateDP() {
  document.getElementById("dp").textContent = "dp: [" + dp.join(", ") + "]";
}

function updateIJLabels() {
  labels.forEach((l, idx) => {
    if (idx === i && idx === j) l.textContent = "i,j";
    else if (idx === i) l.textContent = "i";
    else if (idx === j) l.textContent = "j";
    else l.textContent = "";
  });
}

function reset() {
  i = 1; j = 0;
  cells.forEach(c => c.classList.remove("active", "lis"));
  build();
}

function step() {
  if (i >= nums.length) {
    const maxLen = Math.max(...dp);
    document.getElementById("result").textContent = "LIS 長度：" + maxLen;

    let lis = [], len = maxLen;
    for (let k = dp.length - 1; k >= 0; k--) {
      if (dp[k] === len && (lis.length === 0 || nums[k] < lis[lis.length - 1])) {
        lis.push(nums[k]);
        cells[k].classList.add("lis");
        len--;
      }
    }
    return;
  }

  cells[i].classList.add("active");
  cells[j].classList.add("active");

  if (nums[i] > nums[j]) {
    dp[i] = Math.max(dp[i], dp[j] + 1);
    updateDP();
  }

  setTimeout(() => {
    cells[i].classList.remove("active");
    cells[j].classList.remove("active");
    j++;
    if (j >= i) {
      j = 0;
      i++;
    }
    updateIJLabels();
  }, 300);
}

function toggle() {
  const section = document.getElementById("lognSection");
  section.style.display = section.style.display === "none" ? "block" : "none";
}
window.onload = build;
</script>

</body>
</html>
